# -*- coding: utf-8 -*-
"""geometrical_optics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jupK-2GfQnCkPbYhcBo8hgB5t-kv9-93

<div dir="rtl" lang="he" xml:lang="he">
<font size=6> עיבוד נתונים - מעבדה א'</font>

<font size=5> מחברת colab גנרית</font>

---
מחברת זו הינה template לעיבוד נתונים במסגרת הקורס מעבדה א'. מצורפים הסברים לכל מקטעי הקוד, ולינקים עם הרחבות למעוניינים. אנו מקווים שהיא תשמש אתכם נאמנה, ותקנה לכם כלים לעיבוד וניתוח נתונים מדעי, אולי גם מחוץ לכותלי הקורס.

כמה הנחיות לשימוש:
המחברת מחולקת למספר פרקים, רצוי להריץ את הבלוקים לפי הסדר (שכן לרוב הם מבוססים אחד על קודמיו). עליכם לשנות את הקוד אך ורק   במקומות המסומנים באמצעות הערה, כלומר ` comment #` .

אנו זמינים לשאלות, ופתוחים להצעות לשיפור!

בהצלחה רבה!

צוות המעבדה

---
<h1>
<font size=5><b>1. ייבוא חבילות</b></font>
</h1>

תחילה, נייבא מספר חבילות פייתון  (Python packages) בהן נשתמש בתהליך עיבוד הנתונים.

החבילה Numpy משמשת בעיקר  לביצוע ביעילות פעולות על מערכים,
 ואילו SciPy, אשר מתבסס על NumPy, מציע פונקציונליות נוספת לאופטימיזציה, וכו'.
החבילה Pandas חיונית לניתוח נתונים, מספקת מבני נתונים גמישים ושימושיים כמו DataFrames ומאפשרת ביצוע מניפולציות על הדאטא.

---
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
from scipy.odr import Model, ODR, RealData
import math
import re
!pip install uncertainties docx math2docx
import uncertainties
import docx
import math2docx
import io
import os

"""<div dir="rtl" lang="he" xml:lang="he">

---
<h1>
<font size=5><b>2. קריאת קבצי CSV</b></font>
</h1>

 כדי לייבא את נתוני הניסוי מתוך קובץ הCSV למחברת זו, יש להמיר את הדאטא לייצוג קריא ונוח חישובית. במחברת זו נייצג את הנתונים בתור אובייקט  DataFrames. נדפיס כאן לפניכם את 5 השורות הראשונות.

 הערה: וודאו שאתם אכן מעלים את קובץ הנתונים שלכם לתיקיה הראשית ("content/"), ע"י גרירת הקובץ למקום המתאים.
 כמו כן וודאו שהעמודות מכילות כותרות.

---
"""

from google.colab import drive
drive.mount('/content/drive', force_remount=True)

from google.colab import auth
auth.authenticate_user()
import requests
gcloud_token = !gcloud auth print-access-token
gcloud_tokeninfo = requests.get('https://www.googleapis.com/oauth2/v3/tokeninfo?access_token=' + gcloud_token[0]).json()
user = gcloud_tokeninfo['email'].split('@')[0]

if user == "amirf2":
  file_path = r"/content/drive/MyDrive/Documents/Physics/Lab 1A/Geometrical Optics/geometrical_optics_data.xlsx" # Replace with your file path: r"/content/<your file name>.xlsx"
if user == "itayfeldman1":
  file_path = r"/content/drive/MyDrive/Physics Lab/LabA1/GeometricalOptics/geometrical_optics_data.xlsx"

sheet_name = 1 # Replace with your sheet number
data = pd.read_excel(file_path, sheet_name=sheet_name)

f_inf, f_inf_error = data.iloc[:,14][0], data.iloc[:,15][0]
f_not_inf, f_not_inf_error = data.iloc[:,16][0], data.iloc[:,17][0]
H, H_error = data.iloc[:,12][0], data.iloc[:,13][0]
print(f_inf, f_inf_error)
print(f_not_inf, f_not_inf_error)
print(H, H_error)

data[:5]

"""<div dir="rtl" lang="he" xml:lang="he">

---
<h1>
<font size=5><b>3. בחירת x, $\Delta$x, y, $\Delta$y </b></font>
</h1>

כעת, נבחר את העמודות המתאימות מתוך הנתונים, לשם ביצוע ההתאמה. ניתן לבחור את העמודות לפי שם (השורה הראשונה בעמודה) או לחילופין לפי האינדקס של העמודה (0, 1, 2...). שוב, נדפיס את השורות הראשונות מתוך העמודות שנבחרו.

---
"""

def choose_columns(columns):
    x = data.iloc[:,columns[0]]
    delta_x = data.iloc[:,columns[1]]
    y = data.iloc[:,columns[2]]
    delta_y = data.iloc[:,columns[3]]
    return x, delta_x, y, delta_y

"""<div dir="rtl" lang="he" xml:lang="he">

---
<h1>
<font size=5><b>4. התאמה לנתונים</b></font>
</h1>

נשתמש באלגוריתם ODR (או Orthogonal Distance Regression) לביצוע ההתאמה. אלגוריתם זה מתאים במקרה של תלות בין משתנים. בניגוד לבעיית המינימיזציה הסטנדרטית בשארים הפחותים, שם ההתחיסות הינה רק למרחק האנכי בין נקודות הדאטא וקו ההתאמה, ODR מבצע מינימיזציה ביחס למרחק האורתוגונלי, מה שמטייב את ההתאמה.
מתודת ODR מתוך הספריה SciPy מצריך הגדרת פונקציית התאמה ומתן ניחושים התחלתיים לפרמטרים. ראו להלן מספר פונקציות התאמה שימושיות, לדוגמא.

---
"""

def function(A, x):
    pass # Define your function. See some examples below.

def linear(A, x):
    return A[1] * x + A[0]

def polynomial(A, x):
    return A[2] * x**2 + A[1] * x + A[0]

def optics(A, x):
    return A[1] * x / (x - A[1]) + A[0]

def exponential(A, x):
    return A[2] * np.exp(A[1] * x) + A[0]

def sinusoidal(A, x):
    return A[3] * np.sin(A[1] * x + A[2]) + A[0]

"""<div dir="rtl" lang="he" xml:lang="he">
 תוכלו להתנסות בבחירת פונקציות התאמה שונות וניחושים התחלתיים שונים:

<div dir="rtl" lang="he" xml:lang="he">
 כעת, נבצע התאמה לנתונים לפי המודל הפונקציונלי הנבחר, באמצעות אלגוריתם ODR:
"""

def odr_fit(fit_func, initial_guesses, x, delta_x, y, delta_y):
    model = Model(fit_func)
    odr_data = RealData(x, y, sx=delta_x, sy=delta_y)
    odr = ODR(data=odr_data, model=model, beta0=initial_guesses)
    output = odr.run()

    fit_params = output.beta
    fit_params_error = output.sd_beta
    fit_cov = output.cov_beta
    return fit_params, fit_params_error, fit_cov, output

"""<div dir="rtl" lang="he" xml:lang="he">

ננתח את הפלט של אלגוריתם ODR:

1. `fit_params`:

הפרמטרים המשוערים של המודל. אלו הם הערכים האופטימליים של הפרמטרים, המתאימים ביותר לנתונים לפי אלגוריתם ODR. הפרמטרים ניתנים לפי אינדקס בסדר עולה: $a_0,a_1,a_2,...$
2. `fit_params_error`:

השגיאה של הפרמטרים המשוערים. ערכים אלו מצביעים על אי הוודאות או השונות באומדני הפרמטרים. שגיאות הפרמטרים ניתנות לפי אינדקס בסדר עולה: $\Delta a_0,\Delta a_1,\Delta a_2,...$
3. `fit_cov`:

מטריצת השונות של הפרמטרים המשוערים. מטריצה ​​זו מספקת מידע על הקורלציה בין צמדי פרמטרים והשונות המשותפת שלהם:

\begin{bmatrix}
\text{Cov}(a_0, a_0) & \text{Cov}(a_0, a_1) & \text{Cov}(a_0, \dots) \\
\text{Cov}(a_1, a_0) & \text{Cov}(a_1, a_1) & \text{Cov}(a_1, \dots) \\
\text{Cov}(\dots, a_0) & \text{Cov}(\dots, a_1) & \text{Cov}(\dots, \dots)
\end{bmatrix}

<div dir="rtl" lang="he" xml:lang="he">

---
<h1>
<font size=5><b>5. חישוב השארים והמדדים הסטטיסטיים</b></font>
</h1>

נחשב את ערכי השארים (residuals) ואת $\chi^2_{red}, p-value$, באופן מפורש.

---
"""

def calc_stats(x, y, fit_params, output, fit_func):
    residuals = y - fit_func(fit_params, x)
    degrees_of_freedom = len(x) - len(fit_params)
    chi2 = output.sum_square
    chi2_red = chi2/degrees_of_freedom
    p_val = stats.chi2.sf(chi2, degrees_of_freedom)
    return residuals, degrees_of_freedom, chi2_red, p_val

"""<div dir="rtl" lang="he" xml:lang="he">

נסביר את משמעות הערכים שהדפסנו:

1. `residuals`:

שארים מתארים את ההפרש בין ערכי הנתונים והערכים החזויים מהמודל. הם מציינים עד כמה המודל מתאים לכל נקודת נתונים בודדת. הפרשים קטנים מעידים על התאמה טובה, ולהיפך.

2. `degrees_of_freedom`:

דרגות חופש (DOF) בהקשר של מודל רגרסיה מתייחס למספר המדידות מהנתונים פחות מספר פרמטרי ההתאמה.

3. `chi2_red`:

חי בריבוע מצומצם ($\chi^2_{red}$) הינו חי בריבוע חלקי מספר דרגות החופש. הוא מספק מדד למידת ההתאמה של המודל לנתונים, תוך התחשבות במספר הפרמטרים המוערכים. ערך קרוב ל-1 מצביע על התאמה טובה, בעוד שערכים גדולים או פחות מ-1 מצביעים על התאמה שאינה מיטבית.
3. `p_val`:

ערך ה-p נגזר מהתפלגות של חי בריבוע ומציין את ההסתברות לקבל ערך חי בריבוע
הקטן בערכו מהערך שקיבלנו מההתאמה, ובמילים אחרות:
$p[\chi^2<\chi^2_{fit}]$.

ערך p בטווח >0.05 או < 0.95 מצביע על כך שהמודל מתאים היטב לנתונים, בעוד שערך p קיצוני, <0.05 או > 0.95 מצביע על כך שהמודל עשוי להיות לא מתאים.


ערכים סטטיסטיים אלה יחד מספקים הערכה מקיפה של התאמת המודל הנבחר לנתונים, ומסייע לבחון את תקפות ההנחות השונות (ביחס לצורה הפונקציונלית של המודל, הערכת השגיאות, וכו...).

<div dir="rtl" lang="he" xml:lang="he">

---
<h1>
<font size=5><b>6. הדפסת פרמטרי ההתאמה ושגיאותיהם, והמדדים הסטטיסטיים הרלוונטיים</b></font>
</h1>

---
"""

def print_output(fit_params, fit_params_error, chi2_red, p_val, degrees_of_freedom):
    for i in range(len(fit_params)):
        print(f"a[{i}]: {fit_params[i]} \u00B1 {fit_params_error[i]} ({(abs(fit_params_error[i]/fit_params[i]))*100}% error)")
    print(f"chi squared reduced = {chi2_red:.5f} \u00B1 {np.sqrt(2/degrees_of_freedom)}")
    print(f"p-probability = {p_val:.5e}")
    print(f"DOF = {degrees_of_freedom}")

"""<div dir="rtl" lang="he" xml:lang="he">

כעת, נבצע את כל תהליך ביצוע ההתאמה והחישובים הנלווים, בבת אחת, ע"י קריאה לכל הפונקציות שראינו לעיל. ראשית נבחר את העמודות הרלוונטיות ונשרטט את הדאטא בלבד (אנא עשו בדיקת שפיות: האם זו התצורה שציפיתם לקבל?):
"""

def check_for_extreme_measurements(residuals, errors):
  residual_to_error_extreme = filter(lambda x: x[1] > 3, [(i, abs(residual / error*2)) for i, (residual, error) in enumerate(zip(residuals, errors))])

  extreme_amount_to_remove = -1*int(3/10 * len(residuals))
  return sorted(residual_to_error_extreme, key=lambda x: x[1])[extreme_amount_to_remove:]

def remove_extremes(data_points, extremes):
  for extreme in extremes:
    for col in data_points:
      col.pop(extreme[0])

def nsigma(v1, v2, v1_error, v2_error):
  return abs(v1 - v2) / math.sqrt((v1_error)**2 + v2_error**2)

def nsigma_with_outer_value(name, outer_val, outer_val_error, param_index, value_index):
  if param_index is not None:
    def nsigma_calc(fit_params, fit_params_error, values):
      n = nsigma(outer_val, outer_val_error, fit_params[param_index], fit_params_error[param_index])
      print(f"nsigma {name}, {n} = {outer_val}+-{outer_val_error} / {fit_params[param_index]}+-{fit_params_error[param_index]}")
      return (f"({name}) \ \ "+"N_{\sigma}", None, n, None)
  else:
    def nsigma_calc(fit_params, fit_params_error, values):
      n = nsigma(outer_val, outer_val_error, values[value_index][2], values[value_index][3])
      print(f"nsigma {name}, {n} = {outer_val}+-{outer_val_error} / {values[value_index][2]}+-{values[value_index][3]}")
      return (f"({name}) \ \ "+"N_{\sigma}", None, n, None)
  return nsigma_calc

def add_math_to_tbl(row, name, dimension, value, error=None):
  row.cells[0].vertical_alignment = docx.enum.table.WD_ALIGN_VERTICAL.CENTER
  row.cells[1].vertical_alignment = docx.enum.table.WD_ALIGN_VERTICAL.CENTER
  par = row.cells[1].add_paragraph()
  if error is None:
    v = f'{uncertainties.ufloat(0, value):.2uf}'
    v = v[v.index('-')+1:]
    p = ''
  else:
    v = f'{uncertainties.ufloat(value, error):.2uf}'.replace('+/-', '\pm ')
    p = f'{uncertainties.ufloat(0, abs((error/value)*100)):.2uf}'
    p = p[p.index('-')+1:]
    p = f'\ \ \ ({p}\%)'
  if dimension is None:
    dimension = ''
  else:
    dimension = f'[{dimension}]'
  math2docx.add_math(par, f"{name} = {v} \ {dimension} {p}")

def fit(columns,
        fit_func,
        initial_guesses,
        parameter_dimensions,
        x_dimension,
        y_dimension,
        fit_title,
        residuals_title,
        calculate_value_functions=None,
        statistical_value_functions=None,
        extremes_to_remove=None):
  calculate_value_functions = list() if calculate_value_functions is None else calculate_value_functions
  statistical_value_functions = list() if statistical_value_functions is None else statistical_value_functions

  # Data
  x, delta_x, y, delta_y = choose_columns(columns)

  figure_num_start = 1
  if extremes_to_remove is not None:
    remove_extremes((x, delta_x, y, delta_y), extremes_to_remove)
    figure_num_start = 100

  # Data graph
  plt.close('all')
  fig, ax = plt.subplots(1, 1, figsize=(6, 6), num=figure_num_start)
  plt.style.use('classic')

  fig.patch.set_facecolor('white')
  ax.set_facecolor('white')

  ax.errorbar(x, y, xerr=delta_x, yerr=delta_y, fmt='.b', label='Data', ecolor='gray') # Change the label if needed

  ax.set_title('Data - add here the full title')  # Add here the full title for the fit
  ax.set_xlabel(f'{data.columns[columns[0]]}') # Change x-axis label if needed
  ax.set_ylabel(f'{data.columns[columns[2]]}') # Change y-axis label if needed

  ax.grid(True)
  ax.legend()

  data_graph = io.BytesIO()
  fig.savefig(data_graph, bbox_inches='tight')
  #Fit
  fit_params, fit_params_error, fit_cov, output = odr_fit(fit_func, initial_guesses, x, delta_x, y, delta_y)
  residuals, degrees_of_freedom, chi2_red, p_val = calc_stats(x, y, fit_params, output, fit_func)
  print_output(fit_params, fit_params_error, chi2_red, p_val, degrees_of_freedom)

  # Fit Graph
  fig, axs = plt.subplots(1, 2, figsize=(15, 6), num=figure_num_start+1)
  plt.style.use('classic')

  fig.patch.set_facecolor('white')
  for ax in axs:
    ax.set_facecolor('white')

  x_fit = np.linspace(min(x), max(x), 10*len(x))
  y_fit = fit_func(fit_params, x_fit)

  axs[0].errorbar(x, residuals, xerr=delta_x, yerr=delta_y, fmt='.b', label="Data", ecolor='gray')
  axs[0].hlines(0, min(x), max(x), colors='r', linestyles='dashed')

  axs[0].set_title(residuals_title) # Add here the full title for the residuals
  axs[0].set_xlabel(f'{data.columns[columns[0]]} {x_dimension}') # Change column names if needed
  axs[0].set_ylabel(f'{data.columns[columns[2]]} - f({data.columns[columns[0]]}) {y_dimension}') # Change column names if needed

  axs[0].grid(True)
  axs[0].legend()

  axs[1].errorbar(x, y, xerr=delta_x, yerr=delta_y, fmt='.b', label='Data', ecolor='gray') # Change the label if needed
  axs[1].plot(x_fit, y_fit, label='Fit', c='r', alpha=0.5) # Change the label if needed

  axs[1].set_title(fit_title)  # Add here the full title for the fit
  axs[1].set_xlabel(f'{data.columns[columns[0]]} {x_dimension}') # Change x-axis label if needed
  axs[1].set_ylabel(f'{data.columns[columns[2]]} {y_dimension}') # Change y-axis label if needed

  axs[1].grid(True)
  axs[1].legend()

  fit_graph = io.BytesIO()
  fig.savefig(fit_graph, bbox_inches='tight')

  plt.tight_layout()
  plt.show()

  # Fit Parameters to Word.
  values = []
  for calculate_value_function in calculate_value_functions:
    values.append(calculate_value_function(fit_params, fit_params_error))

  for statistical_value_function in statistical_value_functions:
    values.append(statistical_value_function(fit_params, fit_params_error, values))

  doc = docx.Document('fit.docx') if os.path.exists('fit.docx') else docx.Document()

  row_count = len(fit_params) + 2 + len(values)
  tbl = doc.add_table(row_count, 2)
  tbl.alignment = docx.enum.table.WD_TABLE_ALIGNMENT.CENTER
  tbl.table_direction = docx.enum.table.WD_TABLE_DIRECTION.RTL
  tbl.autofit = True
  for i in range(len(fit_params)):
    add_math_to_tbl(tbl.rows[i], f'a_{i}', parameter_dimensions[i], fit_params[i], fit_params_error[i])
  add_math_to_tbl(tbl.rows[len(fit_params)], '\chi_{red}^2', None, chi2_red, np.sqrt(2/degrees_of_freedom))
  add_math_to_tbl(tbl.rows[len(fit_params)+1], 'P_{prob}', None, p_val)
  for i, value in enumerate(values):
    add_math_to_tbl(tbl.rows[len(fit_params)+2+i], value[0], value[1], value[2], value[3])

  doc.add_picture(data_graph)
  doc.add_picture(fit_graph)

  doc.save('fit.docx')
  data_graph.close()
  fit_graph.close()
  a = None
  if p_val > 0.95 or p_val < 0.05 and extremes_to_remove is None:
    # Try Removing extreme measurements
    print("Trying to remove extremes for better fit.")
    extreme_measurements = check_for_extreme_measurements(residuals, delta_y)
    print(extreme_measurements)
    a = fit(columns, fit_func, initial_guesses, parameter_dimensions, x_dimension, y_dimension,
        fit_title, residuals_title, calculate_value_functions, statistical_value_functions, extreme_measurements)
  if a is None:
    return x, delta_x, y, delta_y, fit_params, fit_params_error, values
  return a

"""<div dir="rtl" lang="he" xml:lang="he">

---
<h1>
<font size=5><b>התאמה 1 - נוסחת העדשות הדקות ליניארית</b></font>
</h1>

---
"""

columns = [0, 1, 2, 3] # Define the columns indices to represent x, delta x, y, delta y.
x, delta_x, y, delta_y = choose_columns(columns)

remove_extremes((x, delta_x, y, delta_y), [(7, 11.800203343131077), (2, 21.047728490477915), (3, 22.88370935912959)])

plt.close('all')
fig, ax = plt.subplots(1, 1, figsize=(6, 6))
plt.style.use('classic')

fig.patch.set_facecolor('white')
ax.set_facecolor('white')

ax.errorbar(x, y, xerr=delta_x, yerr=delta_y, fmt='.b', label='Data', ecolor='gray') # Change the label if needed

ax.set_title('Data - add here the full title')  # Add here the full title for the fit
ax.set_xlabel(f'{data.columns[columns[0]]}') # Change x-axis label if needed
ax.set_ylabel(f'{data.columns[columns[2]]}') # Change y-axis label if needed

ax.grid(True)
ax.legend()

plt.tight_layout()
plt.show()

fit_func = linear # Choose your fit function name
initial_guesses = (0, 0,) # Define the initial guesses for the parameters in list "A" (make sure they are the same length, and in the same order!)
fit_params, fit_params_error, fit_cov, output = odr_fit(fit_func, initial_guesses, x, delta_x, y, delta_y)
residuals, degrees_of_freedom, chi2_red, p_val = calc_stats(x, y, fit_params, output, fit_func)
print_output(fit_params, fit_params_error, chi2_red, p_val, degrees_of_freedom)

f, f_error = 1/fit_params[0], fit_params_error[0]/(fit_params[0]**2)
print(f"\nguessed f: {f} \u00B1 {f_error} ({(f_error/f)*100}% error)")

n_sigma = abs(f - f_inf) / math.sqrt((f_error)**2 + f_inf_error**2)
print(f"N sigma for f = {n_sigma}")

n_sigma = abs(fit_params[1] + 1) / math.sqrt(fit_params_error[1])
print(f"N sigma for a1 = {n_sigma}")

"""<div dir="rtl" lang="he" xml:lang="he">
<font size=5 color="red"> אופציונאלי:</font>
נדפיס את הפלט הסטנדרטי המלא, לקבלת מידע מלא יותר על תהליך ביצוע ההתאמה (לפירוט, ראו את הדוקומנטציה).

[דוקומנטציה](https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.Output.html)
"""

output.pprint()

"""<div dir="rtl" lang="he" xml:lang="he">

---
<h1>
<font size=5><b>7. שרטוט גרף הנתונים, פונקציית ההתאמה, וגרף השארים</b></font>
</h1>

נשרטט את ערכי הנתונים ושגיאותיהם (שימו לב שגם השגיאה בציר x משורטטת באיור זה, אם כי בשל מימדיה הקטנים היא לא נראית בבירור בגרף), ואת פונקציית ההתאמה שחישבנו ביחס אליהם, באיור השמאלי, ואילו את גרף השארים באיור הימני. תוכלו לשנות ולהתאים את פסקת הקוד הבאה לצרכיכם ולטעמכם, וכן להוסיף עוד עקומות במידת הנדרש. שימו לב שעליכם לערוך את הכותרות הראשיות לגרפים, כותרות הצירים, ולהוסיף יחידות.

---
"""

plt.close('all')
fig, axs = plt.subplots(1, 2, figsize=(15, 6))
plt.style.use('classic')

fig.patch.set_facecolor('white')
for ax in axs:
    ax.set_facecolor('white')

x_fit = np.linspace(min(x), max(x), 10*len(x))
y_fit = fit_func(fit_params, x_fit)
axs[0].errorbar(x, y, xerr=delta_x, yerr=delta_y, fmt='.b', label='Data', ecolor='gray') # Change the label if needed
axs[0].plot(x_fit, y_fit, label='Fit', c='r', alpha=0.5) # Change the label if needed

# If you want to plot multiple functions, change here the relevant parameters (x, y, xerr, yerr, label). Otherwise, uncomment the 2 next lines:
#axs[0].errorbar(x + 0.2, y + 0.3, xerr=delta_x, yerr=delta_y, fmt='.g', label='Data', ecolor='gray')
#axs[0].plot(x_fit + 0.2, y_fit + 0.3, label='Fit', c='k', alpha=0.5)

axs[0].set_title('Thin Lens Approximation - Linear Fit')  # Add here the full title for the fit
axs[0].set_xlabel(f'{data.columns[columns[0]]} [1/cm]]') # Change x-axis label if needed
axs[0].set_ylabel(f'{data.columns[columns[2]]} [1/cm]') # Change y-axis label if needed

axs[0].grid(True)
axs[0].legend()

axs[1].errorbar(x, residuals, xerr=delta_x, yerr=delta_y, fmt='.b', label="Data", ecolor='gray')
axs[1].hlines(0, min(x), max(x), colors='r', linestyles='dashed')

axs[1].set_title('Thin Lens Approximation - Linear Fit Residuals') # Add here the full title for the residuals
axs[1].set_xlabel(f'{data.columns[columns[0]]} [1/cm]') # Change column names if needed
axs[1].set_ylabel(f'{data.columns[columns[2]]} - f({data.columns[columns[0]]}) [1/cm]') # Change column names if needed

axs[1].grid(True)
axs[1].legend()

plt.tight_layout()
plt.show()

print(check_for_extreme_measurements(residuals, delta_y))

columns = [4, 5, 6, 7] # Define the columns indices to represent x, delta x, y, delta y.
x, delta_x, y, delta_y = choose_columns(columns)

remove_extremes((x, delta_x, y, delta_y), [(6, 11.685203558189603), (3, 19.978762542781155), (2, 21.322929385474538)])

plt.close('all')
fig, ax = plt.subplots(1, 1, figsize=(6, 6))
plt.style.use('classic')

fig.patch.set_facecolor('white')
ax.set_facecolor('white')

ax.errorbar(x, y, xerr=delta_x, yerr=delta_y, fmt='.b', label='Data', ecolor='gray') # Change the label if needed


ax.set_title('Data - add here the full title')  # Add here the full title for the fit
ax.set_xlabel(f'{data.columns[columns[0]]}') # Change x-axis label if needed
ax.set_ylabel(f'{data.columns[columns[2]]}') # Change y-axis label if needed

ax.grid(True)
ax.legend()

plt.tight_layout()
plt.show()

fit_func = optics # Choose your fit function name
initial_guesses = (0, f_inf,) # Define the initial guesses for the parameters in list "A" (make sure they are the same length, and in the same order!)
fit_params, fit_params_error, fit_cov, output = odr_fit(fit_func, initial_guesses, x, delta_x, y, delta_y)
residuals, degrees_of_freedom, chi2_red, p_val = calc_stats(x, y, fit_params, output, fit_func)
print_output(fit_params, fit_params_error, chi2_red, p_val, degrees_of_freedom)

print(f"\nguessed f: {fit_params[1]} \u00B1 {fit_params_error[1]} ({(fit_params_error[1]/fit_params[1])*100}% error)")

n_sigma = abs(fit_params[1] - f_inf) / math.sqrt((fit_params_error[1])**2 + f_inf_error**2)
print(f"N sigma f to f_inf = {n_sigma}")

n_sigma = abs(f - fit_params[1]) / math.sqrt((f_error)**2 + fit_params_error[1]**2)
print(f"N sigma f to linear f = {n_sigma}")

print(f"a0: {fit_params[0]}, v_min {min(y)}, propotion: {min(y)/abs(fit_params[0])}")

"""<div dir="rtl" lang="he" xml:lang="he">
<font size=5 color="red"> אופציונאלי:</font>
נדפיס את הפלט הסטנדרטי המלא, לקבלת מידע מלא יותר על תהליך ביצוע ההתאמה (לפירוט, ראו את הדוקומנטציה).

[דוקומנטציה](https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.Output.html)
"""

output.pprint()

"""<div dir="rtl" lang="he" xml:lang="he">

---
<h1>
<font size=5><b>7. שרטוט גרף הנתונים, פונקציית ההתאמה, וגרף השארים</b></font>
</h1>

נשרטט את ערכי הנתונים ושגיאותיהם (שימו לב שגם השגיאה בציר x משורטטת באיור זה, אם כי בשל מימדיה הקטנים היא לא נראית בבירור בגרף), ואת פונקציית ההתאמה שחישבנו ביחס אליהם, באיור השמאלי, ואילו את גרף השארים באיור הימני. תוכלו לשנות ולהתאים את פסקת הקוד הבאה לצרכיכם ולטעמכם, וכן להוסיף עוד עקומות במידת הנדרש. שימו לב שעליכם לערוך את הכותרות הראשיות לגרפים, כותרות הצירים, ולהוסיף יחידות.

---
"""

plt.close('all')
fig, axs = plt.subplots(1, 2, figsize=(15, 6))
plt.style.use('classic')

fig.patch.set_facecolor('white')
for ax in axs:
    ax.set_facecolor('white')

x_fit = np.linspace(min(x), max(x), 10*len(x))
y_fit = fit_func(fit_params, x_fit)
axs[0].errorbar(x, y, xerr=delta_x, yerr=delta_y, fmt='.b', label='Data', ecolor='gray') # Change the label if needed
axs[0].plot(x_fit, y_fit, label='Fit', c='r', alpha=0.5) # Change the label if needed

# If you want to plot multiple functions, change here the relevant parameters (x, y, xerr, yerr, label). Otherwise, uncomment the 2 next lines:
#axs[0].errorbar(x + 0.2, y + 0.3, xerr=delta_x, yerr=delta_y, fmt='.g', label='Data', ecolor='gray')
#axs[0].plot(x_fit + 0.2, y_fit + 0.3, label='Fit', c='k', alpha=0.5)

axs[0].set_title('Thin Lens Approximation - Non-Linear Fit')  # Add here the full title for the fit
axs[0].set_xlabel(f'{data.columns[columns[0]]} [cm]') # Change x-axis label if needed
axs[0].set_ylabel(f'{data.columns[columns[2]]} [cm]') # Change y-axis label if needed

axs[0].grid(True)
axs[0].legend()

axs[1].errorbar(x, residuals, xerr=delta_x, yerr=delta_y, fmt='.b', label="Data", ecolor='gray')
axs[1].hlines(0, min(x), max(x), colors='r', linestyles='dashed')

axs[1].set_title('Thin Lens Approximation - Non-Linear Fit Residuals') # Add here the full title for the residuals
axs[1].set_xlabel(f'{data.columns[columns[0]]} [cm]') # Change column names if needed
axs[1].set_ylabel(f'{data.columns[columns[2]]} - f({data.columns[columns[0]]}) [cm]') # Change column names if needed

axs[1].grid(True)
axs[1].legend()

plt.tight_layout()
plt.show()

print(check_for_extreme_measurements(residuals, delta_y))

"""<div dir="rtl" lang="he" xml:lang="he">

---
<h1>
<font size=5><b>התאמה 3 - נוסחת ההגדלה ליניארית</b></font>
</h1>

---
"""

columns = [8, 9, 10, 11] # Define the columns indices to represent x, delta x, y, delta y.
x, delta_x, y, delta_y = choose_columns(columns)

plt.close('all')
fig, ax = plt.subplots(1, 1, figsize=(6, 6))
plt.style.use('classic')

fig.patch.set_facecolor('white')
ax.set_facecolor('white')

ax.errorbar(x, y, xerr=delta_x, yerr=delta_y, fmt='.b', label='Data', ecolor='gray') # Change the label if needed


ax.set_title('Data - add here the full title')  # Add here the full title for the fit
ax.set_xlabel(f'{data.columns[columns[0]]}') # Change x-axis label if needed
ax.set_ylabel(f'{data.columns[columns[2]]}') # Change y-axis label if needed

ax.grid(True)
ax.legend()

plt.tight_layout()
plt.show()

fit_func = linear # Choose your fit function name
initial_guesses = (0, 0,) # Define the initial guesses for the parameters in list "A" (make sure they are the same length, and in the same order!)
fit_params, fit_params_error, fit_cov, output = odr_fit(fit_func, initial_guesses, x, delta_x, y, delta_y)
residuals, degrees_of_freedom, chi2_red, p_val = calc_stats(x, y, fit_params, output, fit_func)
print_output(fit_params, fit_params_error, chi2_red, p_val, degrees_of_freedom)

n_sigma = abs(H - fit_params[1]) / math.sqrt((H_error)**2 + fit_params_error[1]**2)
print(f"n-sigma H to -a_1 = {n_sigma}")

"""<div dir="rtl" lang="he" xml:lang="he">
<font size=5 color="red"> אופציונאלי:</font>
נדפיס את הפלט הסטנדרטי המלא, לקבלת מידע מלא יותר על תהליך ביצוע ההתאמה (לפירוט, ראו את הדוקומנטציה).

[דוקומנטציה](https://docs.scipy.org/doc/scipy/reference/generated/scipy.odr.Output.html)
"""

output.pprint()

"""<div dir="rtl" lang="he" xml:lang="he">

---
<h1>
<font size=5><b>7. שרטוט גרף הנתונים, פונקציית ההתאמה, וגרף השארים</b></font>
</h1>

נשרטט את ערכי הנתונים ושגיאותיהם (שימו לב שגם השגיאה בציר x משורטטת באיור זה, אם כי בשל מימדיה הקטנים היא לא נראית בבירור בגרף), ואת פונקציית ההתאמה שחישבנו ביחס אליהם, באיור השמאלי, ואילו את גרף השארים באיור הימני. תוכלו לשנות ולהתאים את פסקת הקוד הבאה לצרכיכם ולטעמכם, וכן להוסיף עוד עקומות במידת הנדרש. שימו לב שעליכם לערוך את הכותרות הראשיות לגרפים, כותרות הצירים, ולהוסיף יחידות.

---
"""

plt.close('all')
fig, axs = plt.subplots(1, 2, figsize=(15, 6))
plt.style.use('classic')

fig.patch.set_facecolor('white')
for ax in axs:
    ax.set_facecolor('white')

x_fit = np.linspace(min(x), max(x), 10*len(x))
y_fit = fit_func(fit_params, x_fit)
axs[0].errorbar(x, y, xerr=delta_x, yerr=delta_y, fmt='.b', label='Data', ecolor='gray') # Change the label if needed
axs[0].plot(x_fit, y_fit, label='Fit', c='r', alpha=0.5) # Change the label if needed

# If you want to plot multiple functions, change here the relevant parameters (x, y, xerr, yerr, label). Otherwise, uncomment the 2 next lines:
#axs[0].errorbar(x + 0.2, y + 0.3, xerr=delta_x, yerr=delta_y, fmt='.g', label='Data', ecolor='gray')
#axs[0].plot(x_fit + 0.2, y_fit + 0.3, label='Fit', c='k', alpha=0.5)

axs[0].set_title('Magnification Factor Equation - Linear Fit')  # Add here the full title for the fit
axs[0].set_xlabel(f'{data.columns[columns[0]]} [cm/cm]') # Change x-axis label if needed
axs[0].set_ylabel(f'{data.columns[columns[2]]} [cm]') # Change y-axis label if needed

axs[0].grid(True)
axs[0].legend()

axs[1].errorbar(x, residuals, xerr=delta_x, yerr=delta_y, fmt='.b', label="Data", ecolor='gray')
axs[1].hlines(0, min(x), max(x), colors='r', linestyles='dashed')

axs[1].set_title('Magnification Factor Equation - Linear Fit Residuals') # Add here the full title for the residuals
axs[1].set_xlabel(f'{data.columns[columns[0]]} [cm/cm]') # Change column names if needed
axs[1].set_ylabel(f'{data.columns[columns[2]]} - fit({data.columns[columns[0]]}) [cm]') # Change column names if needed

axs[1].grid(True)
axs[1].legend()

plt.tight_layout()
plt.show()

def calculate_linear_f(fit_params, fit_params_error):
  return "f", "cm", 1/fit_params[0], fit_params_error[0]/(fit_params[0]**2)

nsigmas = [nsigma_with_outer_value("finf", f_inf, f_inf_error, None, 0),
           nsigma_with_outer_value("a1", -1, 0, 1, None)]
x, delta_x, y, delta_y, fit_params, fit_params_error, values = fit([0,1,2,3], linear, (0,0), ("1/cm", None), "[1/cm]", "[1/cm]",
    'Thin Lens Approximation - Linear Fit', "Thin Lens Approximation - Linear Fit Residuals",
    [calculate_linear_f], nsigmas)
f_linear, f_linear_error = values[0][2], values[0][3]

def calculate_non_linear_f(fit_params, fit_params_error):
    return "f", "cm", fit_params[1], fit_params_error[1]

nsigmas = [nsigma_with_outer_value("finf", f_inf, f_inf_error, None, 0),
           nsigma_with_outer_value("prev", f_linear, f_linear_error, None, 0)]

x, delta_x, y, delta_y, fit_params, fit_params_error, values = fit([4,5,6,7], optics, (0, f_inf,), ("cm", "cm"), "[cm]", "[cm]",
                                                                   "Thin Lens Approximation - Non-Linear Fit", "Thin Lens Approximation - Non-Linear Fit Residuals",
                                                                   [calculate_non_linear_f], nsigmas)

print(f"a0: {fit_params[0]}, v_min {min(y)}, propotion: {min(y)/abs(fit_params[0])}")

def calcuate_H(fit_params, fit_params_error):
  return "H", "cm", fit_params[1], fit_params_error[1]

nsigmas = [nsigma_with_outer_value("H", H, H_error, None, 0)]
x, delta_x, y, delta_y, fit_params, fit_params_error, values = fit([8,9,10,11], linear, (0, 0,), ("cm", "cm"), "[cm/cm]", "[cm]",
    "Magnification Factor Equation - Linear Fit", "Magnification Factor Equation - Linear Fit Residuals",
    [calcuate_H], nsigmas)

print(f"a0: {fit_params[0]}, v_min {min(y)}, propotion: {min(y)/abs(fit_params[0])}")